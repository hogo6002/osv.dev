package main

import (
	"reflect"
	"testing"

	"github.com/google/osv/vulnfeeds/cves"
)

func TestReposFromReferences(t *testing.T) {
	type args struct {
		CVE         string
		cache       VendorProductToRepoMap
		vp          *VendorProduct
		refs        []cves.Reference
		tagDenyList []string
	}
	tests := []struct {
		name      string
		args      args
		wantRepos []string
	}{
		{
			name: "A CVE with a repo not already present in the VendorRepo cache",
			args: args{
				CVE:   "CVE-2023-0327",
				cache: nil,
				vp:    &VendorProduct{"theradsystem_project", "theradsystem"},
				refs: []cves.Reference{
					{
						Source: "cna@vuldb.com",
						Tags:   []string{"Patch", "Third Party Advisory"},
						Url:    "https://github.com/saemorris/TheRadSystem/commit/bfba26bd34af31648a11af35a0bb66f1948752a6"},
				},
				tagDenyList: RefTagDenyList,
			},
			wantRepos: []string{"https://github.com/saemorris/TheRadSystem"},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if gotRepos := ReposFromReferences(tt.args.CVE, tt.args.cache, tt.args.vp, tt.args.refs, tt.args.tagDenyList); !reflect.DeepEqual(gotRepos, tt.wantRepos) {
				t.Errorf("ReposFromReferences() = %v, want %v", gotRepos, tt.wantRepos)
			}
		})
	}
}

func Test_maybeUpdateVPRepoCache(t *testing.T) {
	type args struct {
		cache VendorProductToRepoMap
		vp    *VendorProduct
		repos []string
	}
	tests := []struct {
		name      string
		args      args
		wantCache VendorProductToRepoMap
	}{
		{
			name: "Test with no cache",
			args: args{
				cache: nil,
				vp:    &VendorProduct{"avendor", "aproduct"},
				repos: []string{"https://github.com/google/osv.dev"},
			},
			wantCache: nil,
		},
		{
			name: "Test with an empty cache",
			args: args{
				cache: VendorProductToRepoMap{},
				vp:    &VendorProduct{"avendor", "aproduct"},
				repos: []string{"https://github.com/google/osv.dev"},
			},
			wantCache: VendorProductToRepoMap{
				VendorProduct{"avendor", "aproduct"}: []string{"https://github.com/google/osv.dev"},
			},
		},
		{
			name: "Test with an empty cache and an unusable repo",
			args: args{
				cache: VendorProductToRepoMap{},
				vp:    &VendorProduct{"avendor", "aproduct"},
				repos: []string{"https://github.com/vendor/repo"},
			},
			wantCache: VendorProductToRepoMap{},
		},
		{
			name: "Test with an existing cache",
			args: args{
				cache: VendorProductToRepoMap{
					VendorProduct{"avendor", "aproduct"}: []string{"https://github.com/google/osv.dev"},
				},
				vp:    &VendorProduct{"avendor", "aproduct"},
				repos: []string{"https://github.com/google/osv-scanner"},
			},
			wantCache: VendorProductToRepoMap{
				VendorProduct{"avendor", "aproduct"}: []string{"https://github.com/google/osv.dev", "https://github.com/google/osv-scanner"},
			},
		},
		{
			name: "Test with an empty cache adding two values",
			args: args{
				cache: VendorProductToRepoMap{},
				vp:    &VendorProduct{"avendor", "aproduct"},
				repos: []string{"https://github.com/google/osv.dev", "https://github.com/google/osv-scanner"},
			},
			wantCache: VendorProductToRepoMap{
				VendorProduct{"avendor", "aproduct"}: []string{"https://github.com/google/osv.dev", "https://github.com/google/osv-scanner"},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			for _, repo := range tt.args.repos {
				maybeUpdateVPRepoCache(tt.args.cache, tt.args.vp, repo)
			}
			if !reflect.DeepEqual(tt.args.cache, tt.wantCache) {
				t.Errorf("maybeUpdateVPRepoCache() have %#v, wanted %#v", tt.args.cache, tt.wantCache)
			}
		})
	}
}
